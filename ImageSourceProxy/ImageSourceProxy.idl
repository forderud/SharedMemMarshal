import "oaidl.idl";
import "ocidl.idl";


cpp_quote("")
cpp_quote("#ifdef __cplusplus")
cpp_quote("} // extern \"C\"")
cpp_quote("")
cpp_quote("#include <cassert>")
cpp_quote("#include <utility>")
cpp_quote("#include <atlsafe.h>")
cpp_quote("")
cpp_quote("extern \"C\"{")
cpp_quote("#endif")
cpp_quote("")

cpp_quote("")
cpp_quote("#ifndef __cplusplus")

typedef [
    helpstring("2D image data struct.")]
    struct Image2d {
    [helpstring("")] double       time;
    [helpstring("pixel encoding")] unsigned int format;
    [helpstring("resolution (#width, #height)")] unsigned short  dims[2];
    [helpstring("underlying image buffer (4 bytes per pixel)")] SAFEARRAY(BYTE) data;
} Image2d;

cpp_quote("")
cpp_quote("#else // __cplusplus")
cpp_quote("} // extern \"C\"")
cpp_quote("")
cpp_quote("/** RAII wrapper for Image2d struct.")
cpp_quote("    Used to ease management and avoid memory leaks. */")
cpp_quote("struct Image2d {")
cpp_quote("    /* Empty default constructor. */")
cpp_quote("    Image2d () {")
cpp_quote("    }")
cpp_quote("")
cpp_quote("    /** Primary constructor. The caller is responsible for populating the data field if passing do_allocate=false.  */")
cpp_quote("    Image2d (double time_, unsigned int format_, const USHORT dims_[2], bool do_allocate = true) : data(nullptr) {")
cpp_quote("        time    = time_;")
cpp_quote("        format  = format_;")
cpp_quote("        dims[0] = dims_[0];")
cpp_quote("        dims[1] = dims_[1];")
cpp_quote("        if (do_allocate)")
cpp_quote("            allocate(size());")
cpp_quote("    }")
cpp_quote("")
cpp_quote("    /** Copy constructor. */")
cpp_quote("    Image2d (const Image2d & obj, bool deep_copy) : data(nullptr) {")
cpp_quote("        time    = obj.time;")
cpp_quote("        format  = obj.format;")
cpp_quote("        dims[0] = obj.dims[0];")
cpp_quote("        dims[1] = obj.dims[1];")
cpp_quote("")
cpp_quote("        ULONG img_size = size();")
cpp_quote("        if (!img_size)")
cpp_quote("            return;")
cpp_quote("")
cpp_quote("        assert(obj.data); // require obj to contain data if non-zero size")
cpp_quote("        if (deep_copy) {")
cpp_quote("            // copy image data")
cpp_quote("            allocate(img_size);")
cpp_quote("            memcpy(data->pvData, obj.data->pvData, img_size);")
cpp_quote("        } else {")
cpp_quote("            // make shallow copy that accesses the same data")
cpp_quote("            if (FAILED(SafeArrayAllocDescriptorEx(VT_UI1, 1, &data))) // sets data[-4] = VT_UI1; data->cDims = 1; data->fFeatures = FADF_HAVEVARTYPE")
cpp_quote("                abort();")
cpp_quote("            data->fFeatures = obj.data->fFeatures | FADF_AUTO; // prevent data from being deleted")
cpp_quote("            data->cbElements = obj.data->cbElements;")
cpp_quote("            data->pvData     = obj.data->pvData;")
cpp_quote("            data->rgsabound[0] = obj.data->rgsabound[0];")
cpp_quote("        }")
cpp_quote("    }")
cpp_quote("")
cpp_quote("    ~Image2d () {")
cpp_quote("        release();")
cpp_quote("    }")
cpp_quote("")
cpp_quote("    /** Move constructor. */")
cpp_quote("    Image2d (Image2d && rhs) {")
cpp_quote("        *this = std::move(rhs);")
cpp_quote("    }")
cpp_quote("")
cpp_quote("    /** Move assignment. */")
cpp_quote("    Image2d& operator = (Image2d && rhs) {")
cpp_quote("        release(); // clean up existing data")
cpp_quote("")
cpp_quote("        // make shallow copy")
cpp_quote("        time    = rhs.time;")
cpp_quote("        format  = rhs.format;")
cpp_quote("        dims[0] = rhs.dims[0];")
cpp_quote("        dims[1] = rhs.dims[1];")
cpp_quote("        data    = rhs.data;")
cpp_quote("")
cpp_quote("        // prevent double delete")
cpp_quote("        rhs.data = nullptr;")
cpp_quote("")
cpp_quote("        return *this;")
cpp_quote("    }")
cpp_quote("")
cpp_quote("    /** Buffer size [bytes]. */")
cpp_quote("    ULONG size () const {")
cpp_quote("        return 4*dims[0]*dims[1];")
cpp_quote("    }")
cpp_quote("")
cpp_quote("protected:")
cpp_quote("    void allocate (ULONG new_size) {")
cpp_quote("        release(); // free old memory before allocating new")
cpp_quote("")
cpp_quote("        // allocate data")
cpp_quote("        data = CComSafeArray<BYTE>(new_size).Detach();")
cpp_quote("    }")
cpp_quote("")
cpp_quote("    void release () {")
cpp_quote("        if (!data)")
cpp_quote("            return;")
cpp_quote("")
cpp_quote("        if (data->fFeatures & FADF_AUTO) {")
cpp_quote("            // delete descriptor manually, since SafeArrayDestroy does nothing")
cpp_quote("            if (FAILED(SafeArrayDestroyDescriptor(data))) // only delete descriptor, not data")
cpp_quote("                abort();")
cpp_quote("            data = nullptr;")
cpp_quote("            return;")
cpp_quote("        }")
cpp_quote("")
cpp_quote("        // deallocate data")
cpp_quote("        CComSafeArray<BYTE> tmp;")
cpp_quote("        if (FAILED(tmp.Attach(data)))")
cpp_quote("            abort();")
cpp_quote("        data = nullptr;")
cpp_quote("    }")
cpp_quote("")
cpp_quote("public:")
cpp_quote("    double         time    = 0;")
cpp_quote("    unsigned int   format  = 0;")
cpp_quote("    unsigned short dims[2] = {0, 0};")
cpp_quote("    SAFEARRAY *    data    = nullptr;")
cpp_quote("private:")
cpp_quote("    Image2d (const Image2d &) = delete;              ///< non-copyable")
cpp_quote("    Image2d & operator = (const Image2d &) = delete; ///< non-assignable")
cpp_quote("};")
cpp_quote("")
cpp_quote("extern \"C\"{")
cpp_quote("#endif")
cpp_quote("")

[object,
oleautomation, // use "automation" marshaler (oleaut32.dll)
uuid(3CBD54F2-C9A5-4E64-A582-B7D6AD14CE3D),
helpstring("Interface for controlling lifetime of 2D image data.")]
interface IImageHandle : IUnknown {
    [helpstring("Get frame data (const). Lifetime controlled by parent IImageHandle object.\n"
        "The operation is usually considered cheap with a zero-copy implementation with some exceptions.")]
        HRESULT GetData([out, retval] Image2d* data);
};


[version(1.0),
 uuid(8E42F33F-E5E3-46B4-8B39-0A03DCF338CC),
 helpstring("ImageSourceProxy module")]
library ImageSourceProxy {
    importlib("stdole2.tlb");

    [version(1.0),
        uuid(9A7D97EB-1491-438E-B88C-234390D727F2),
        helpstring("Class for testing shared memory")]
        coclass ImageHandleProxy {
        [default] interface IImageHandle;
        interface IMarshal;
    };
};
