import "oaidl.idl";
import "ocidl.idl";

cpp_quote("")
cpp_quote("#ifdef __cplusplus")
cpp_quote("} // extern \"C\"")
cpp_quote("")
cpp_quote("#include <cassert>")
cpp_quote("#include <utility>")
cpp_quote("#include <atlsafe.h>")
cpp_quote("")
cpp_quote("extern \"C\"{")
cpp_quote("#endif")
cpp_quote("")

cpp_quote("")
cpp_quote("#ifndef __cplusplus")

typedef [
    helpstring("2D image data struct.")]
    struct Image2d {
    [helpstring("")] double       time;
    [helpstring("pixel encoding")] unsigned int format;
    [helpstring("resolution (#width, #height)")] unsigned short  dims[2];
    [helpstring("underlying image buffer (4 bytes per pixel)")] SAFEARRAY(BYTE) data;
} Image2d;

cpp_quote("")
cpp_quote("#else // __cplusplus")
cpp_quote("} // extern \"C\"")
cpp_quote("")
cpp_quote("/** RAII wrapper for Image2d struct.")
cpp_quote("    Used to ease management and avoid memory leaks. */")
cpp_quote("struct Image2d {")
cpp_quote("    /* Empty default constructor. */")
cpp_quote("    Image2d () {")
cpp_quote("    }")
cpp_quote("")
cpp_quote("    /** Primary constructor. The caller is responsible for populating the data field if passing do_allocate=false.  */")
cpp_quote("    Image2d (double time_, unsigned int format_, const USHORT dims_[2], bool do_allocate = true) : data(nullptr) {")
cpp_quote("        time    = time_;")
cpp_quote("        format  = format_;")
cpp_quote("        dims[0] = dims_[0];")
cpp_quote("        dims[1] = dims_[1];")
cpp_quote("        if (do_allocate)")
cpp_quote("            allocate(size());")
cpp_quote("    }")
cpp_quote("")
cpp_quote("    /** Deep-copy constructor. */")
cpp_quote("    Image2d (const Image2d & obj) : data(nullptr) {")
cpp_quote("        time    = obj.time;")
cpp_quote("        format  = obj.format;")
cpp_quote("        dims[0] = obj.dims[0];")
cpp_quote("        dims[1] = obj.dims[1];")
cpp_quote("")
cpp_quote("        ULONG img_size = size();")
cpp_quote("        if (!img_size)")
cpp_quote("            return;")
cpp_quote("")
cpp_quote("        assert(obj.data); // require obj to contain data if non-zero size")
cpp_quote("        // copy image data")
cpp_quote("        allocate(img_size);")
cpp_quote("        memcpy(data->pvData, obj.data->pvData, img_size);")
cpp_quote("    }")
cpp_quote("")
cpp_quote("    /** Copy constructor with custom SAFEARRAY data. */")
cpp_quote("    Image2d (const Image2d & obj, SAFEARRAY* sa) : data(nullptr) {")
cpp_quote("        time    = obj.time;")
cpp_quote("        format  = obj.format;")
cpp_quote("        dims[0] = obj.dims[0];")
cpp_quote("        dims[1] = obj.dims[1];")
cpp_quote("")
cpp_quote("        // use custom data array")
cpp_quote("        assert(sa->fFeatures & FADF_AUTO);")
cpp_quote("        data = sa;")
cpp_quote("    }")
cpp_quote("")
cpp_quote("    ~Image2d () {")
cpp_quote("        release();")
cpp_quote("    }")
cpp_quote("")
cpp_quote("    /** Move constructor. */")
cpp_quote("    Image2d (Image2d && rhs) {")
cpp_quote("        *this = std::move(rhs);")
cpp_quote("    }")
cpp_quote("")
cpp_quote("    /** Move assignment. */")
cpp_quote("    Image2d& operator = (Image2d && rhs) {")
cpp_quote("        release(); // clean up existing data")
cpp_quote("")
cpp_quote("        // make shallow copy")
cpp_quote("        time    = rhs.time;")
cpp_quote("        format  = rhs.format;")
cpp_quote("        dims[0] = rhs.dims[0];")
cpp_quote("        dims[1] = rhs.dims[1];")
cpp_quote("        data    = rhs.data;")
cpp_quote("")
cpp_quote("        // prevent double delete")
cpp_quote("        rhs.data = nullptr;")
cpp_quote("")
cpp_quote("        return *this;")
cpp_quote("    }")
cpp_quote("")
cpp_quote("    /** Buffer size [bytes]. */")
cpp_quote("    ULONG size () const {")
cpp_quote("        return 4*dims[0]*dims[1];")
cpp_quote("    }")
cpp_quote("")
cpp_quote("protected:")
cpp_quote("    void allocate (ULONG new_size) {")
cpp_quote("        release(); // free old memory before allocating new")
cpp_quote("")
cpp_quote("        // allocate data")
cpp_quote("        data = CComSafeArray<BYTE>(new_size).Detach();")
cpp_quote("    }")
cpp_quote("")
cpp_quote("    void release () {")
cpp_quote("        if (!data)")
cpp_quote("            return;")
cpp_quote("")
cpp_quote("        // deallocate data (does nothing if FADF_AUTO is set)")
cpp_quote("        CComSafeArray<BYTE> tmp;")
cpp_quote("        if (FAILED(tmp.Attach(data)))")
cpp_quote("            abort();")
cpp_quote("        data = nullptr;")
cpp_quote("    }")
cpp_quote("")
cpp_quote("public:")
cpp_quote("    double         time    = 0;")
cpp_quote("    unsigned int   format  = 0;")
cpp_quote("    unsigned short dims[2] = {0, 0};")
cpp_quote("    SAFEARRAY *    data    = nullptr;")
cpp_quote("private:")
cpp_quote("    Image2d & operator = (const Image2d &) = delete; ///< non-assignable")
cpp_quote("};")
cpp_quote("")
cpp_quote("extern \"C\"{")
cpp_quote("#endif")
cpp_quote("")

[object,
oleautomation, // use "automation" marshaler (oleaut32.dll)
uuid(3CBD54F2-C9A5-4E64-A582-B7D6AD14CE3D),
helpstring("Interface for controlling lifetime of 2D image data.")]
interface IImageHandle : IUnknown {
    [helpstring("Get frame data (const). Lifetime controlled by parent IImageHandle object.\n"
        "The operation is usually considered cheap with a zero-copy implementation with some exceptions.")]
    HRESULT GetData([out, retval] Image2d* data);
};

[object,
oleautomation, // use "automation" marshaler (oleaut32.dll)
uuid(7D278258-3B05-45D3-AD60-CF65497B56B6),
helpstring("Interface for accessing shared-memory segment handles.")]
interface IHandleMgr : IUnknown {
    HRESULT GetImageHandle([out, retval] IImageHandle** obj);
};

[version(1.0),
uuid(ECC2EB22-C8CB-4034-993C-158F68FCD39E),
helpstring("ImageSource module")]
library ImageSource {
    importlib("stdole2.tlb");

    [version(1.0),
        uuid(C8767698-8297-4BE1-904E-FC25034851D2),
        helpstring("Class for testing shared memory")]
    coclass HandleMgr {
        [default] interface IHandleMgr;
    };
};
